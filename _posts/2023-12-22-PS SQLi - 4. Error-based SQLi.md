---
title: PS SQLi - 4. Error-based SQLi
date: 2023-12-22
categories: [Training, PortSwigger]
tags: [portswigger, sqli, sql, burp, error-based-sqli]
img_path: /assets/portswigger/sqli/error_based_sqli
published: true
---

## Error-based SQLi

**Error-based SQLi** refers to cases where we are able to use error messages to either extract or infer sensitive data from the database, even in blind contexts. The possibilities depend on the database configuration and the error types we are able to trigger:
- We may be able to induce the app to return a specific error response based on the result of a boolean expression. We can exploit this in the same way as the [condition responses](https://cspanias.github.io/posts/PS-SQLi-3.-Blind-SQLi/#exploiting-blind-sqli-by-triggering-conditional-responses).
- We may be able to trigger error messages that output the data returned by the query. This effectively turns otherwise blind SQLi vulnerabilities into visible ones ([extracting sensitive data via verbose SQL error messages](https://portswigger.net/web-security/sql-injection/blind#extracting-sensitive-data-via-verbose-sql-error-messages)).

## Exploiting blind SQLi by triggering conditional errors

Some apps carry out SQL queries but their behavior does not change, regardless of whether the query returns any data, thus, the [Blind SQLi](https://cspanias.github.io/posts/PS-SQLi-3.-Blind-SQLi/) techniques won't work, because injecting different boolean conditions makes no difference to the app's responses. 

It's often possible to induce the app to return a different response depending on whether a SQL error occurs. We can modify the query so that it causes a database error only if the condition is true. Very often, an unhandled error thrown by the database causes some difference in the app's response time, such as an error message. This enables us to infer the truth of the injected condition.

Suppot that two requests are sent containing the following `TrackingId` cookie values in turn:

![](cookie_values.png){: .normal}

These inpus use the `CASE` keyword to test a condition and return a different expression depending on whether the expression is true:
- With the first input, the `CASE` expression evaluates to `'a'`, which does not cause any error.
- With the second input, it evaluates to `1/0`, which causes a divide-by-zero error.

If the error causes a difference in the app's HTTP response, we can use this to determine whether the injected condition is true. Using this technique, we can retrieve data by testing one character at a time:

```sql
xyz' AND (SELECT CASE WHEN (Username = 'Administrator' AND SUBSTRING(Password, 1, 1) > 'm') THEN 1/0 ELSE 'a' END FROM Users)='a
```

> There are different ways of triggering conditional errors, and different techniques work best on different database types. For more details, see the [SQLi Cheatsheet](https://portswigger.net/web-security/sql-injection/cheat-sheet).

### Lab: Blind SQL injection with conditional errors

> **Objective**: _This lab contains a blind SQLi vulnerability. The application uses a tracking cookie for analytics, and performs a SQL query containing the value of the submitted cookie. The results of the SQL query are not returned, and the application does not respond any differently based on whether the query returns any rows. If the SQL query causes an error, then the application returns a custom error message. The database contains a different table called `users`, with columns called `username` and `password`. You need to exploit the blind SQLi vulnerability to find out the password of the `administrator` user. To solve the lab, log in as the `administrator` user._

1. Let's start as usual, by testing for SQLi, 

    ![](lab1_sqli_test.png)

    ![](lab1_sqli_test1.png)

2. The above test suggests that a **syntax error** is having a detectable effect on the response. We now need to confirm that the server is interpreting the injection as a SQL query, i.e., that the error is a SQL syntax error as opposed to any other kind of error. To do this, we first need to construct a subquery using valid SQL syntax:

    ![](lab1_error_type.png)

    ![](lab1_error_type1.png)

3. The queries above indicate that the sever is indeed interpreting the injection as a SQL query, and that we are dealing with an Oracle database which requires all `SELECT` statements to explicitly specify a table name. We can confirm the database type as follows:

    ![](lab1_version.png)

4. Now we now the database type, we can pass an invalid query while preserving valid SQL syntax to be sure that our injection is being processed as a SQL query by the server:

    ![](lab1_error_type2.png)

5. As long as we inject syntactically valid SQL queries, we can use this error response to infer key info about the database. For example, in order to verify that the `users` table exists:

    ![](lab1_users.png)

    > The `WHERE ROWNUM=1` condition is important here to prevent the query from returning more than one row, which would break our concatenation.

6. Next, we want confirm that the user `administrator` exists. If we use a normal query (without inducing any error) we wouldn't be able to confirm that the user exists because no matter which user we tested for, we would always received a HTTP 200 reponse:

    ![](lab1_where_admin.png)

    ![](lab1_where_test.png)

6. What we need to do is to construct a query that includes an error-generating expression and make sure that it works as intended:

    ![](lab1_case.png)

    ![](lab1_case1.png)

7. So we can now swap the `dual` table with the info we need to test, i.e., check if the user `administrator` exists:

    ![](lab1_case_admin_true.png)

    ![](lab1_case_admin_false.png)

    The above works due to SQL's [order of operations](https://learnsql.com/blog/sql-order-of-operations/):

    ![](sql_order_of_operations.png)

    ![](lab1_case_explanation.png)

8. Now we can modify our query and find out the password length. Again, when we get a `500` response that confirms our query:

    ![](lab1_pass_length_8.png)

    ![](lab1_pass_length_20_plus.png)

    ![](lab1_pass_length_20.png)

9. The password is 20 characters long, so we can now use Intruder to brute force its characters one-by-one:

    ![](lab1_payload_pos.png)

    ![](lab1_payload_settings_1.png){: .normal}

    ![](lab1_payload_settings_2.png){: .normal}

    ![](lab1_filter_results.png){: .normal}

    ![](lab1_pass_results.png){: .normal}

10. Now we can log in with the `administrator` account and mark this lab as solved:

    ![](lab1_solved.png)

## Resources

- [SQL injection](https://portswigger.net/web-security/learning-paths/sql-injection).
- [SQLi Cheatsheet](https://portswigger.net/web-security/sql-injection/cheat-sheet).
- Related practice: [DVWA SQLi](https://cspanias.github.io/posts/DVWA-SQL-Injection/), [DVWA SQLi (Blind)](https://cspanias.github.io/posts/DVWA-SQL-Injection-(Blind)/).
- Rhana's [video walkthrough](https://www.youtube.com/watch?v=_7w-KEP_K5w).
- [SQL Order of Operations](https://learnsql.com/blog/sql-order-of-operations/).