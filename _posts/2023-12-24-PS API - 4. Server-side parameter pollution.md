---
title: 4. Server-side parameter pollution
date: 2023-12-24
categories: [PortSwigger, API testing]
tags: [portswigger, api, api-testing, server-side-parameter-pollution, sspp]
img_path: /assets/portswigger/api/param_pollution
published: true
---

## Server-side parameter pollution (SSPP)

Some systems contain internal APIs that aren't directly accessible from the internet. **SSPP**, aka **HTTP parameter pollution**, occurs when a website embeds user input in a server-side request to an internal API without adequate encoding. This means that an attacker may be able to manipulate or inject params, which may enable them to:
- Override existing params.
- Modify the app's behavior.
- Access unauthorized data.

We can test any user input for any kind of parameter pollution: query-parameters, form fields, headers, and URL path parameters.

## Testing for SSPP in the query string

To test for SSPP in the query string, we can place syntax characters, such as `#`, `&`, and `=`, in our input and observe how the app responds. Consider a vulnerable app that enables us to search for other users based on their username. When we search for a user, our browser makes the following request: `GET /userSearch?name=peter&back=/home`. To retrieve user info, the server queries an internal API with the following request: `GET /users/search?name=peter&publicProfile=true`.

## Truncating query strings

We can use a URL-encoded `#` character to attempt to truncate the server-side request. To help us interpret the response, we could also add a string after the `#` character. For instance, we could modify the query as follows: `GET /userSearch?name=peter%23foo&back=/home`. The front-end will try to access the following URL: `GET /users/search?name=peter#foo&publicProfile=true`.

> It is essential that we URL-encode the `#` character. Otherwise, the front-end app will interpret it as a fragment identifier and it won't be passed to the internal API.

We can then review the response for clues about whether the query has been truncated. For example, if the response returns the user `peter`, the server-side query may have been truncated. If an `Invalid name` error message is returned, the app may have treated `foo` as part of the username. This suggests that the server-side request many not have been truncated. 

If we are able to truncate the server-side request, this removes the requirement for the `publicProfile` firled to be set to `true`. We may be able to exploit this to return non-public user profiles.

## Injecting invalid parameters

We can use an URL-encoded `&` character to attempt to add a second parameter to the server-side request. For example, we could modify the query string as follows: `GET /userSearch?name=peter%26foo=xyz&back=/home`. This would result in the following server-side request to the internal API: `GET /users/search?name=peter&foo=xyz&publicProfile=true`.

We should then review the response for clues about how the additional parameter is parsed. For instance, if the response is unchanged this may indicate that the parameter was successfully injected but ignored by the app. To build up a more complete picture, we will need to test further.

## Injecting valid parameters

If we are able to modify the query string, we can then attempt to add a second valid parameter to the server-side request. For example, if we have identified the `email` parameter, we could add it to the query string: `GET /userSearch?name=peter%26email=foo&back=/home`. This will result in the following server-side request to the internal API: `GET /users/search?name=peter&email=foo&publicProfile=true`.

Again, we should then review the response for clues about how the additional parameter is parsed.

## Overriding existing parameters

To confirm whether the app is vulnerable to SSPP, we could try to override the original parameter. We can do this by injecting a second parameter with the same name: `GET /userSearch?name=peter%26name=carlos&back=/home`. This will be translated to the following server-side request to the internal API: `GET /users/search?name=peter&name=carlos&publicProfile=true`.

The internal API interprets two `name` parameters. The impact of this depends on how the app processes the second parameter. This varies across different web technologies:
- **PHP parses the last parameter only**. This would result in a user search for `carlos`.
- **ASP.NET combines both parameters**. This would result in a user search for `peter,carlos`, which might result in an `Invalid username` error message.
- **Node.js/express parses the first parameter only**. This would result in a user search for `peter`, giving an unchanged result.

If we are able to override the original parameter, we may be able to conduct an exploit. For instance, we could add `name=administrator` to the request which may enable us to log in as the user `administrator`.

### Lab: Exploiting server-side parameter pollution in a query string

> **Objective**: _To solve the lab, log in as the `administrator` and delete `carlos`._

1. On the site, there is a *Forgot password* functionality. Let's use this for the `administrator` account:

    ![](lab1_forgot_pass.png){: width="60%" .normal}

    ![](lab1_admin_reset.png){: width="70%" .normal}

    ![](lab1_check_email.png){: width="80%" .normal}

2. If we check Burp Proxy's HTTP history, there is a `POST` request to `/forgot-password`:

    ![](lab1_forgot_burp.png)

3. We can start playing around with the request's parameters and examine its responses. For example, we can change `username`'s value:

    ![](lab1_adminx_burp.png)

4. We got an `Invalid username` error message, so let's try something else, such as adding a second parameter using a URL-encoded `&`:

    ![](lab1_add_param.png)

5. This time we got a `Parameter is not supported` error message. This suggests that the internal API may have interpreted `&x=y` as a separate parameter, instead of part of the username. We can also try to truncate the request using a URL-encoded `#`:

    ![](lab1_truncated.png)

6. We now got a `Field not specified` error message, which indicates that the server-side query may include an additional parameter called `field`, which has been removed by the `#` character. We can try and add `field` back:

    ![](lab1_field.png)

7. The `Invalid field` error message suggests that the server-side request app may recognize the injected `field` parameter. We now need to brute-force its value:

    > We can find the required wordlist [here](https://raw.githubusercontent.com/antichown/burp-payloads/master/Server-side%20variable%20names.pay).

    ```shell
    $ wget https://raw.githubusercontent.com/antichown/burp-payloads/master/Server-side%20variable%20names.pay
    --2023-12-25 15:37:18--  https://raw.githubusercontent.com/antichown/burp-payloads/master/Server-side%20variable%20names.pay
    Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.108.133, 185.199.109.133, 185.199.111.133, ...
    Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.108.133|:443... connected.
    HTTP request sent, awaiting response... 200 OK
    Length: 19302 (19K) [text/plain]
    Saving to: ‘Server-side variable names.pay’

    Server-side variable names.pay                       100%[===================================================================================================================>]  18.85K  --.-KB/s    in 0s

    2023-12-25 15:37:18 (57.4 MB/s) - ‘Server-side variable names.pay’ saved [19302/19302]
    ```

    ![](lab1_intruder_positions.png)

    ![](lab1_intruder_payload.png){: width="70%" .normal}

    ![](lab1_intruder_results.png){: width="70%" .normal}

8. We notice that both the `username` and `email` strings seem to be valid values for the `field` parameter based on the response status code, i.e. `200`:

    ![](lab1_field_username.png)

    ![](lab1_field_email.png)

9. In Proxy's HTTP history there is a JavaScript file containing an endpoint with the parameter `reset_token`:

    ![](lab1_js_resetToken.png)

10. If we change the value of the `field` parameter to `reset_token` we will see that the response includes a password reset token:

    ![](lab1_pass_token.png)

11. If we use the `reset_token` endpoint and pass as its value the token we just got, we will be able to change `administrator`'s password:

    ![](lab1_reset_admin_pass.png)

12. We can now login as `administrator` and delete `carlos`:

    ![](lab1_delete_carlos.png)

    ![](lab1_solved.png)

## Testing for SSPP in REST paths

## Resources

- [API testing](https://portswigger.net/web-security/learning-paths/api-testing).