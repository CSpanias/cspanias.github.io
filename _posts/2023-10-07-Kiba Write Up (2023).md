---
title: Kiba CTF Write Up (2023)
date: 2023-10-07
categories: [CTF Write Up, THM]
tags: [kibana, gtfobins, prototypepollution, rce, capabilities]
img_path: /assets/kiba/
mermaid: true
---

![kiba_banner](kiba_banner.png)

## 1 Summary

[![](https://mermaid.ink/img/pako:eNpdkLFOAzEMhl8lMstVaqXOGZBoDxhoRVXYCIN7cWjUXHxKfEJV1RdhYebteARyvQXwYuv_7U_yf4KGLYEGF_i92WMStdqaqErdvDz4HUZ8VbOZ2iQWlmNHasMh9OI5FvlacV1V2-WtMiZ-f358TSZaa8c8Eor52xutgbbEDnc-ePGUB_v--e5x4WO-IBdVYpZ_VyPQxL-9CZhzTU4N3CyJD6Sv3HwOU2gpteht-ew07BqQPbVkQJfRYjoYMPFc9rAXfjrGBrSknqbQdxaFao9vCVvQDkMuKlkvnNZjVJfEzj_4vmhX?type=png)](https://mermaid.live/edit#pako:eNpdkLFOAzEMhl8lMstVaqXOGZBoDxhoRVXYCIN7cWjUXHxKfEJV1RdhYebteARyvQXwYuv_7U_yf4KGLYEGF_i92WMStdqaqErdvDz4HUZ8VbOZ2iQWlmNHasMh9OI5FvlacV1V2-WtMiZ-f358TSZaa8c8Eor52xutgbbEDnc-ePGUB_v--e5x4WO-IBdVYpZ_VyPQxL-9CZhzTU4N3CyJD6Sv3HwOU2gpteht-ew07BqQPbVkQJfRYjoYMPFc9rAXfjrGBrSknqbQdxaFao9vCVvQDkMuKlkvnNZjVJfEzj_4vmhX)

## 2 Background Information

The [Kiba](https://tryhackme.com/room/kiba) room required a lot of reading for me, as everything was new, and I mean that literally, e-v-e-r-y-t-h-i-n-g! So let's dive right in as we will learning a lot through the excellent room's questions 👏 . 

### 2.1 Kibana software

Kiba is short for **[Kibana](https://www.tutorialspoint.com/kibana/index.htm)**, a browser visualization tool mainly used for analyzing large volumes of logs in the form of graphs. 

Usually it is combined with **Elasticsearch** and **Logstash**, and when combined they are known as the **ELK stack**. Logstash collects the data from various sources, pushes them to Elasticsearch, which then acts as the database for Kibana which represents it as visualizations.

![elk_stack](https://www.tutorialspoint.com/kibana/images/elk_stack.jpg)

## 3 CTF Process

### 3.1 Prototype-based Pollution to RCE

The first question asks us about a vulnerability specific to programming languages with **prototyped-based inheritance**. No idea, so let's Google it:

![prototype_pollution](q1-prototype-based-inheritance.png)

Based on the excellent [PortSwigger's article](https://portswigger.net/daily-swig/prototype-pollution-the-dangerous-and-underrated-vulnerability-impacting-javascript-applications):

>**Prototype Pollution** is a type of vulnerability that allows attackers to exploit the rules of the programming language. By **prototype-based** we mean that when new objects are created, they carry over the properties and methods of the protorype object, which contains basic functionalities.
>
>**Object-based inheritance** gives flexibility and efficiency for programmers, but it also introduces vulnerabilities. By modifying just one object, someone can make application-wide changes to all objects, hence the name **prototype pollution**.

On the aforementioned article, there is a simple JavaScript example, demonstrating how we can achieve **cross-site scripting (XSS)** using this concept, which we can try on [Playcode](https://playcode.io/javascript) and get a better feel for it:
![js-example](pp1.png]
![js-example2](pp2.png)

A bit later in the article, there is a mention to another [article](https://portswigger.net/daily-swig/elk-stack-exploit-for-kibana-remote-code-execution-flaw-released-on-github) from PortSwigger, which explains how to use prototype pollution on Kibana to gain **Remote Code Execution (RCE)**, and also gives us the CVE number of this vulnerability, the answer for the third question 🥂 !

According to this, there are two ways of doing it:
1. Directly from Kibana's dashboard as explained [here](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/) from the Securitum researcher Michał Bentkowski.
2. By executing a read-made python exploit script as explained [here](https://www.tenable.com/blog/cve-2019-7609-exploit-script-available-for-kibana-remote-code-execution-vulnerability). 

The vulnerability, as [officially explained](https://discuss.elastic.co/t/elastic-stack-6-6-1-and-5-6-15-security-update/169077) by Elastic, seemed simple enough:

>*Kibana versions before 5.6.15 and 6.6.1 contain an arbitrary code execution flaw in the Timelion visualizer. An attacker with access to the Timelion application could send a request that will attempt to execute javascript code. This could possibly lead to an attacker executing arbitrary commands with permissions of the Kibana process on the host system.*

By reading the article, we can discover in which port Kibana listens:

![kibana_port](port.png)

Upon visiting the service on the browser, we can see Kibana's dashboard:

![kibana_dashboard](kibana_dashboard.png)

By exploring a bit more, we can find its version under the Management tab (the answer of the second question 🍻):

![kibana_version](kibana_version.jpg)

After trying the code shown on this, and with trying almost every reverse shell mentioned on [HighOn.Coffee's blog](https://highon.coffee/blog/reverse-shell-cheat-sheet/#php-reverse-shell) the connection failed instantly: 

![rce_failed](rce_fail.png)

As a result, we can go with the second approach instead! We can clone the [GitHub repo](https://github.com/LandGrey/CVE-2019-7609/), execute the script (notice that's written in **Python2**), open a listener, receive our reserve shell and get our first 🚩!

![rce_success](rce_success.jpg)

### 3.2 Capabilities

The next questions asks us about **Capabilities**, and if we visit the web server it says: "_Welcome, 'linux capabilities' is very interesting_". So, let's find out what they are!

From [Linux manual page](https://man7.org/linux/man-pages/man7/capabilities.7.html):

>For the purpose of performing permission checks, traditional UNIX implementations distinguish two categories of processes:
1. _privileged_ processes (whose effective user ID is 0, referred to as superuser or root) 
2. _unprivileged_ processes (whose effective UID is nonzero)
>
>Privileged processes bypass all kernel permission checks, while unprivileged processes are subject to full permission checking based on the process's credentials (usually: effective UID, effective GID, and supplementary group list).
>
>Starting with Linux 2.2, **Linux divides the privileges traditionally associated with superuser into distinct units, known as capabilities, which can be independently enabled and disabled. Capabilities are a per-thread attribute**.

In brief, capabilities provide granular control of the root permissions. By reading this [HackTricks article](https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities#binaries-capabilities), we can find out that binaries can also have capabilities and we can use the `getcap` command to search for them.

By searching recursively (answer to the sixth question 😘), we can see that there is a hidden directory named `/.hackmeplease/python3`! 

![binary_cap_search](binary_cap_search.png)

Visiting [GTFOBins](https://gtfobins.github.io/#python) and following the guidance in the [Capabilities section](https://gtfobins.github.io/gtfobins/python/#capabilities), we can get root access and find our root flag 🚩!

![root_flag.jpg](root_flag.jpg)